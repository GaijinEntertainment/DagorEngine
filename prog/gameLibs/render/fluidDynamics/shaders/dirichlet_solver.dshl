include "shader_global.dshl"
include "differential_utils.dshl"

texture cfd_initial_potential_tex;
texture cfd_potential_tex;
texture solid_boundaries_tex;
int4 cfd_tex_size;

float cfd_simulation_dt = 0;
float cfd_simulation_dx = 0;

float cfd_solver_push_val = 0.001;

shader dirichlet_initial_conditions
{
  ENABLE_ASSERT(cs)

  (cs) {
    potential_tex@uav = cfd_potential_tex hlsl {
      RWTexture3D<float2> potential_tex@uav;
    };
    tex_size@i3 = (cfd_tex_size.x, cfd_tex_size.y, cfd_tex_size.z, 0);
  }

  hlsl(cs) {
    [numthreads(8, 8, 1)]
    void cs_main(uint3 tid : SV_DispatchThreadID)
    {
      if (tid.x >= tex_size.x || tid.y >= tex_size.y || tid.z >= tex_size.z)
        return;

      float2 result = 0;
      result.x = (tex_size.x - tid.x - 1) / float(tex_size.x);
      result.y = (tex_size.y - tid.y - 1) / float(tex_size.y);

      potential_tex[tid] = result;
    }
  }
  compile("cs_5_0", "cs_main")
}

shader dirichlet_initial_conditions_from_tex
{
  ENABLE_ASSERT(cs)

  (cs) {
    initial_potential_tex@smp3d = cfd_initial_potential_tex;
    potential_tex@uav = cfd_potential_tex hlsl {
      RWTexture3D<float2> potential_tex@uav;
    };
    tex_size@i3 = (cfd_tex_size.x, cfd_tex_size.y, cfd_tex_size.z, 0);
  }
  hlsl(cs) {
    [numthreads(8, 8, 1)]
    void cs_main(uint3 tid : SV_DispatchThreadID)
    {
      if (tid.x >= tex_size.x || tid.y >= tex_size.y || tid.z >= tex_size.z)
        return;

      potential_tex[tid] = tex3Dlod(initial_potential_tex, float4(float3(tid + 0.5) / float3(tex_size), 0)).xy;
    }
  }

  compile("cs_5_0", "cs_main")
}

shader dirichlet_solver
{
  ENABLE_ASSERT(cs)
  USE_DIFFERENTIAL_UTILS(cs)

  (cs) {
    tex_size@i3 = (cfd_tex_size.x, cfd_tex_size.y, cfd_tex_size.z, 0);
    tau@f1 = (cfd_simulation_dt, 0, 0, 0);
    h@f1 = (cfd_simulation_dx, 0, 0, 0);
    push_val@f1 = (cfd_solver_push_val, 0, 0, 0);

    solid_boundaries@smp3d = solid_boundaries_tex;
  }

  hlsl(cs) {
    #define x_ofs uint3(1, 0, 0)
    #define y_ofs uint3(0, 1, 0)

    Texture3D<float2> potential_tex : register(t1);
    RWTexture3D<float2> next_potential_tex : register(u0);

    [numthreads(8, 8, 1)]
    void cs_main(uint3 tid : SV_DispatchThreadID)
    {
      if (tid.x >= tex_size.x || tid.y >= tex_size.y || tid.z >= tex_size.z)
        return;

      float2 nextPotential = 0;

      uint boundaryData = uint(round(tex3Dlod(solid_boundaries, float4(float3(tid + 0.5) / float3(tex_size), 0)).x * 32.0));
      bool inside = (boundaryData & 1);
      bool boundaries[4] =
      {
        (boundaryData & (1 << 1)), // Top
        (boundaryData & (1 << 2)), // Right
        (boundaryData & (1 << 3)), // Bottom
        (boundaryData & (1 << 4))  // Left
      };

      float2 centerPotential = potential_tex[tid];
      ValueCross2 crossPotential =
      {
        potential_tex[tid - x_ofs],
        potential_tex[tid + x_ofs],
        potential_tex[tid - y_ofs],
        potential_tex[tid + y_ofs]
      };

      // Dirichlet boundary conditions are applied here and used in the laplacian
      ValueCross crossPotentialHorizontal =
      {
        tid.x == 0 ? 1.0 : crossPotential.left.x,
        tid.x == tex_size.x - 1 ? 0.0 : crossPotential.right.x,
        tid.y == 0 ? (tex_size.x - tid.x - 1) / float(tex_size.x) : crossPotential.top.x,
        tid.y == tex_size.y - 1 ? (tex_size.x - tid.x - 1) / float(tex_size.x) : crossPotential.bottom.x
      };
      ValueCross crossPotentialVertical =
      {
        tid.x == 0 ? (tex_size.y - tid.y - 1) / float(tex_size.y) : crossPotential.left.y,
        tid.x == tex_size.x - 1 ? (tex_size.y - tid.y - 1) / float(tex_size.y) : crossPotential.right.y,
        tid.y == 0 ? 1.0 : crossPotential.top.y,
        tid.y == tex_size.y - 1 ? 0.0 : crossPotential.bottom.y
      };

      nextPotential.x = centerPotential.x + tau * (inside ? laplacian(centerPotential.x, crossPotentialHorizontal, h)
                                                          : boundaryAwareLaplacian(centerPotential.x, crossPotentialHorizontal, h, boundaries, push_val));
      nextPotential.y = centerPotential.y + tau * (inside ? laplacian(centerPotential.y, crossPotentialVertical, h)
                                                          : boundaryAwareLaplacian(centerPotential.y, crossPotentialVertical, h, boundaries, push_val));

      next_potential_tex[tid] = nextPotential;
    }
  }
  compile("cs_5_0", "cs_main")
}